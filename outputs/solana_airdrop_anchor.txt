// Anchor program template: Dojo3 Airdrop (minimal, illustrative)
// Build with: anchor build
// Notes: This template focuses on on-chain accounting and referral flow; off-chain
// eligibility (holding > $100 in specific assets) must be validated off-chain and
// provided to the chain as a signed proof (Merkle / attestation). Keep the on-chain
// logic small and gas-efficient.

use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, TokenAccount, Token, Transfer};

declare_id!("REPLACE_WITH_PROGRAM_ID");

const TOTAL_SUPPLY: u64 = 850_000_000; // tokens (human-readable)
const AIRDROP_PERCENT: u64 = 60; // 60% of total
const PUBLIC_PERCENT: u64 = 40; // 40% public sale
const REFERRAL_BPS: u64 = 2400; // 24% (in basis points, where 10000 == 100%)

#[program]
pub mod dojo3_airdrop {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, token_decimals: u8) -> Result<()> {
        let cfg = &mut ctx.accounts.config;
        cfg.admin = *ctx.accounts.admin.key;
        cfg.mint = *ctx.accounts.mint.to_account_info().key;
        cfg.token_decimals = token_decimals;
        cfg.total_supply = TOTAL_SUPPLY;
        cfg.airdrop_pool = (TOTAL_SUPPLY.checked_mul(AIRDROP_PERCENT).unwrap()) / 100;
        Ok(())
    }

    /// Register an airdrop claim.
    /// Off-chain system must generate and sign an `EligibilityProof` (recommended: Merkle proof)
    /// that attests `recipient_weight` and optional `referrer` address. Chain verifies the proof
    /// (or the program accepts a pre-validated signed attestation).
    pub fn claim_airdrop(ctx: Context<ClaimAirdrop>, recipient_amount: u64, referrer: Option<Pubkey>) -> Result<()> {
        let cfg = &mut ctx.accounts.config;

        // Basic checks
        require!(recipient_amount > 0, AirdropError::ZeroAmount);

        // Deduct from pool (simple accounting). In production use token transfers from a treasury token account.
        require!(cfg.airdrop_pool >= recipient_amount, AirdropError::InsufficientPool);
        cfg.airdrop_pool = cfg.airdrop_pool.checked_sub(recipient_amount).unwrap();

        // Transfer tokens to recipient token account
        let seeds = &[b"treasury".as_ref(), ctx.program_id.as_ref(), &[cfg.treasury_bump]];
        let signer = &[&seeds[..]];

        let cpi_accounts = Transfer {
            from: ctx.accounts.treasury_token_account.to_account_info(),
            to: ctx.accounts.recipient_token_account.to_account_info(),
            authority: ctx.accounts.treasury_authority.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        token::transfer(CpiContext::new_with_signer(cpi_program, cpi_accounts, signer), recipient_amount)?;

        // Referral split: compute 24% of recipient_amount (referral gets 24% of recipient's allocation)
        if let Some(ref_pk) = referrer {
            let referral_amount = recipient_amount.checked_mul(REFERRAL_BPS).unwrap() / 10000u64;
            if referral_amount > 0 {
                // Transfer referral_amount to referrer token account (provided by caller)
                let cpi_accounts_ref = Transfer {
                    from: ctx.accounts.treasury_token_account.to_account_info(),
                    to: ctx.accounts.referrer_token_account.to_account_info(),
                    authority: ctx.accounts.treasury_authority.to_account_info(),
                };
                token::transfer(CpiContext::new_with_signer(cpi_program, cpi_accounts_ref, signer), referral_amount)?;
                // Note: we have already deducted recipient_amount from pool; if referral is paid from same pool,
                // either subtract referral_amount additionally or design accounting so recipient_amount is net after referral.
                // This template assumes referral is extra and will further deduct from pool:
                cfg.airdrop_pool = cfg.airdrop_pool.checked_sub(referral_amount).unwrap();
            }
        }

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = admin, space = 8 + 128)]
    pub config: Account<'info, Config>,
    #[account(mut)]
    pub admin: Signer<'info>,
    pub mint: Account<'info, Mint>,
    /// CHECK: Treasury authority PDA
    pub treasury_authority: UncheckedAccount<'info>,
    #[account(mut)]
    pub treasury_token_account: Account<'info, TokenAccount>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ClaimAirdrop<'info> {
    #[account(mut, has_one = mint)]
    pub config: Account<'info, Config>,
    /// CHECK: treasury authority PDA
    pub treasury_authority: UncheckedAccount<'info>,
    #[account(mut)]
    pub treasury_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub recipient_token_account: Account<'info, TokenAccount>,
    // referrer token account must be provided if a referrer is used
    #[account(mut)]
    pub referrer_token_account: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
}

#[account]
pub struct Config {
    pub admin: Pubkey,
    pub mint: Pubkey,
    pub token_decimals: u8,
    pub total_supply: u64,
    pub airdrop_pool: u64,
    pub treasury_bump: u8,
}

#[error_code]
pub enum AirdropError {
    #[msg("Airdrop pool depleted or insufficient funds")]
    InsufficientPool,
    #[msg("Zero amount not allowed")]
    ZeroAmount,
}

/* Deployment notes
- Build: `anchor build`
- Anchor.toml (example):
[provider]
cluster = "https://api.mainnet-beta.solana.com" # or testnet/devnet
wallet = "$HOME/.config/solana/id.json"

[programs.localnet]
dojo3_airdrop = "REPLACE_WITH_PROGRAM_ID"

- Off-chain: compute eligible recipients and weights, create a Merkle tree or signed attestations, and pass a compact proof into `claim_airdrop` so the chain can verify eligibility without storing huge lists on-chain.
- Accounting: prefer minting to an escrow treasury and transferring from treasury token account.
- Token decimals: choose consistent decimals (e.g., 9). Convert human amounts to token units off-chain.
*/
